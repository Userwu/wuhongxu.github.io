<html>
<head>
<title>index</title>

<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
	.markdown-body {
		box-sizing: border-box;
		min-width: 200px;
		max-width: 980px;
		margin: 0 auto;
		padding: 45px;
	}

	@media (max-width: 767px) {
		.markdown-body {
			padding: 15px;
		}
	}
</style>
<link rel="stylesheet" href="css/github.css"/></head>
<body class="markdown-body"><pre class="vditor-yml-front-matter"><code class="language-yaml">title: kubernetes基础使用笔记
createdDate: &quot;2021-05-12&quot;
updatedDate: &quot;2021-05-12&quot;
tags:
  - kubernetes
origin: true
draft: false</code></pre>
<h1>创建集群</h1>
<p>Minikube 是由 Kubernetes 社区维护的单机版的 Kubernetes 集群。</p>
<p><code>minikube version</code> 查看 minikube 安装情况。</p>
<p><code>minikube start</code> 运行 minikube。</p>
<p><code>minikube status</code> 查看 minikube 的运行状态。</p>
<p><code>kubectl version</code> 查看 kubectl 安装情况。</p>
<p><code>kubectl cluster-info</code> 查看集群给中的运行细节。</p>
<p><code>kubectl get nodes</code> 查看集群给中的节点。</p>
<h1>部署应用</h1>
<p><strong>Deployment</strong> 主要用于指挥 Kubernetes 如何创建和更新应用程序的实例。</p>
<blockquote>
<p>创建应用程序实例后，Kubernetes Deployment 控制器会持续监视这些实例。 如果托管实例的节点关闭或被删除，则 Deployment 控制器会将该实例替换为群集中另一个节点上的实例。 这提供了一种自我修复机制来解决机器故障维护问题。</p>
</blockquote>
<pre><code class="highlight-chroma">kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1
</code></pre>
<p>部署示例应用的 Deployment。</p>
<p><code>kubectl get deployments</code> 查看所有的 Deployment</p>
<p>Kubernetes 内部运行的 Pod 在私有的隔离网络上运行。 默认情况下，它们在同一 kubernetes 集群中的其他 Pod 和服务中可见，但在该网络外部不可见。为此可以通过 <code>kubectl proxy</code> 开启一个代理来访问。</p>
<blockquote>
<p>注意这里需要打开新的控制台，这是一个代理服务</p>
</blockquote>
<p><code>export POD_NAME=$(kubectl get pods -o go-template --template '{{range .items}}{{.metadata.name}}{{&quot;\n&quot;}}{{end}}')</code> 这可以输出 pod 名字。</p>
<h1>了解应用</h1>
<p>Pod 是 Kubernetes 抽象出来的，表示一组一个或多个应用程序容器（如 Docker)，以及这些容器的一些共享资源。这资源包括</p>
<ul>
<li>共享存储，当作卷。</li>
<li>网络，作为唯一的集群 IP 地址。</li>
<li>有关每个容器如何运行的信息，例如容器映像版本或要使用的特定端口。</li>
</ul>
<p>Pod 是一组一个或多个应用程序容器（例如 Docker），包括共享存储（卷), IP 地址和有关如何运行它们的信息。</p>
<p>Pod 是 kubernetes 中的最小单元，Deployment 会创建 Pod 而不是具体的容器，每个 Pod 与调度它的工作节点绑定，并保持在那里知道终止或删除。如果工作节点发生故障，则会在集群中的其他可用工作节点上调度相同的 Pod。</p>
<blockquote>
<p>Pod 可能包含多个容器</p>
</blockquote>
<p>一个 Pod 总是运行在<strong>工作节点</strong>。工作节点是 Kubernetes 中的参与计算的机器，可以是虚拟机或物理计算机，具体取决于集群。每个工作节点由主节点管理。工作节点可以有多个 pod ，Kubernetes 主节点会自动处理在群集中的工作节点上调度 pod 。 主节点的自动调度考量了每个工作节点上的可用资源。</p>
<p>每个 Kubernetes 工作节点至少运行:</p>
<ul>
<li>Kubelet，负责 Kubernetes 主节点和工作节点之间通信的过程; 它管理 Pod 和机器上运行的容器。</li>
<li>容器运行时（如 Docker）负责从仓库中提取容器镜像，解压缩容器以及运行应用程序。</li>
</ul>
<p><code>kubectl get pods</code> 查看现有的 pods</p>
<p><code>kubectl describe pods</code> 查 pod 中有哪些容器以及用于构建这些容器的镜像。</p>
<p><code>kubectl descibe pods/&lt;[pod name]&gt;</code> 查看具体某个 pod。</p>
<p><code>kubectl logs &lt;pod name&gt;</code> 查看 pod 日志</p>
<p><code>kubectl exec &lt;pod name&gt; -- env</code> 在 pod 中执行 env 命令，就是普通的 Linux 命令，目标应该是该 pod 的容器</p>
<p><code>kubectl exec -ti &lt;pod name&gt; -- bash</code> -it 这里应该是与 docker 类似，可交互控制台。</p>
<h1>公开暴露应用</h1>
<p>Kubernetes 的 Service 是一个抽象层，它定义了一组 Pod 的逻辑集，并为这些 Pod 支持外部流量暴露、负载平衡和服务发现。</p>
<p>Service 通过标签和选择器进行 Pod 分组匹配。</p>
<p><code>kubectl get services</code> 获取正在运行的 Service。</p>
<p>暴露一个服务 <code>kubectl expose deployment/kubernetes-bootcamp --type=&quot;NodePort&quot; --port 8080</code>，类型指定为 NodePort，minikube 不支持 LoadBalancer。</p>
<ul>
<li>ClusterIP (默认) - 在集群的内部 IP 上公开 Service 。这种类型使得 Service 只能从集群内访问。</li>
<li>NodePort - 使用 NAT 在集群中每个选定 Node 的相同端口上公开 Service 。使用<NodeIP>:<NodePort> 从集群外部访问 Service。是 ClusterIP 的超集。</li>
<li>LoadBalancer - 在当前云中创建一个外部负载均衡器(如果支持的话)，并为 Service 分配一个固定的外部 IP。是 NodePort 的超集。</li>
<li>ExternalName - 通过返回带有该名称的 CNAME 记录，使用任意名称(由 spec 中的 externalName 指定)公开 Service。不使用代理。这种类型需要 kube-dns 的 v1.7 或更高版本。</li>
</ul>
<p>部署完成后可通过 minikube 的 ip 地址 + 使用 <code>kubectl describe services/kubernetes-bootcamp</code> 中的 NodePort 中的端口进行访问。</p>
<p><code>kubectl get pods -l app=kubernetes-bootcamp</code> 通过标签名获取 Pod。</p>
<p><code>kubectl get services -l app=kubernetes-bootcamp</code> 通过标签名获取 service。</p>
<p><code>kubectl label pod &lt;pod name&gt; version=v1</code> 为 pod 打上标签</p>
<p><code>kubectl get pods -l version=v1</code> 通过-l 指令带上 label 获取 Pod。</p>
<p><code>kubectl delete service -l app=kubernetes-bootcamp</code> 删除服务。</p>
<h1>缩放应用</h1>
<p>在运行 kubectl run 命令时，可以通过设置 --replicas 参数来设置 Deployment 的副本数。</p>
<p><code>kubectl get rs</code> 查看副本</p>
<pre><code class="language-bash highlight-chroma">$ kubectl get rs
NAME                            DESIRED   CURRENT   READY   AGE
kubernetes-bootcamp-fb5c67579   <span class="highlight-m">1</span>         <span class="highlight-m">1</span>         <span class="highlight-m">1</span>       36s
</code></pre>
<ul>
<li>副本名字是按照[DEPLOYMENT-NAME]-[随机字符串]，类似 <code>kubernetes-bootcamp-fb5c67579</code>。</li>
<li>DESIRED 显示所需的应用程序副本数，这些副本数是在创建 Deployment 时定义的。 这是所需的状态。</li>
<li>CURRENT 显示当前正在运行多少个副本。</li>
</ul>
<p><code>kubectl scale deployments/kubernetes-bootcamp --replicas=4</code> 扩充为 4 个副本。</p>
<p><code>kubectl get pods -o wide</code> 查看 pods。</p>
<p><code>kubectl describe deployments/kubernetes-bootcamp</code> 查看 Deploment 信息，其中 Replicas 变更为 4 个。</p>
<h1>更新应用</h1>
<p>滚动更新允许通过使用新的实例逐步更新 Pod 实例从而实现 Deployments 更新，停机时间为零。</p>
<p>滚动更新允许以下操作：</p>
<ul>
<li>将应用程序从一个环境提升到另一个环境（通过容器镜像更新）</li>
<li>回滚到以前的版本</li>
<li>持续集成和持续交付应用程序，无需停机</li>
</ul>
<p><code>kubectl set image deployments/kubernetes-bootcamp kubernetes-bootcamp=jocatalin/kubernetes-bootcamp:v2</code> set image 命令能更新镜像。通知 Deployment 为应用程序使用其他映像，并启动了滚动更新。</p>
<p><code>kubectl rollout status deployments/kubernetes-bootcamp</code> 确认滚动状态。</p>
<p><code>kubectl rollout undo deployments/kubernetes-bootcamp</code> 回滚更新。</p>
</body>
</html>